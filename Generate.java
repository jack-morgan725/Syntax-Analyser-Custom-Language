
import java.util.HashMap;
import java.util.Collections;

/**
 * Used to output the parse tree generated by the syntax analyser.
 * @Author Jack Morgan
 */
public class Generate extends AbstractGenerate
{
	// Global symbol table for variables.
	private HashMap<String, Variable> variables = new HashMap<>();
	private int NumberOfIndents = 0;

	/**
	 * Outputs location of error and throws a CompilationException.
	 * @param token the erroneous token.
	 * @param explanatoryMessage a message explaining the reason for the error.
	 * @throws CompilationException
	 */
    public void reportError(Token token, String explanatoryMessage) throws CompilationException
	{
		System.out.printf("%n-------------------------------------------------------------------------------------------------------");
		System.out.printf("------------------------------------------------------------------------------------------------------->%n");
		System.out.println(">	rggERROR at " + Token.getName(token.symbol)  + " at line " + token.lineNumber + ": " + explanatoryMessage);
		System.out.printf("-------------------------------------------------------------------------------------------------------");
		System.out.printf("------------------------------------------------------------------------------------------------------->%n");

		CompilationException exception = new CompilationException("rggERROR at " + Token.getName(token.symbol)  + "at line " + token.lineNumber + ": " + explanatoryMessage, token.lineNumber);
		throw exception;
	}

	/**
	 * Adds a variable to the symbol list if it doesn't already exist.
	 * @param v the variable to add
	 */
	public void addVariable(Variable v)
	{
		// Checking if the variable doesn't exist in the symbol table.
		if (getVariable(v.identifier) == null)
		{
			variables.put(v.identifier, v);
			System.out.println(String.join("", Collections.nCopies(NumberOfIndents, "    ")) + "rggDECL " + v);
		}
	}

	/**
	 * Returns a variable associated with an identifier or null if no such variable exists.
	 * @param identifier the identifier to match
	 * @return
	 */
	public Variable getVariable(String identifier)
	{
		return variables.get(identifier);
	}

	/**
	 * Removes a variable from the symbol table providing it exists.
	 * @param v the variable to remove
	 */
	public void removeVariable(Variable v)
	{
		// Checking if variable already exists in the symbol table.
		if (getVariable(v.identifier) != null)
		{
			variables.remove(v);
			System.out.println(String.join("", Collections.nCopies(NumberOfIndents, "    ")) + "rggDROP " + v);
		}
	}

	/**
	 * Outputs a string displaying a terminal that has been accepted.
	 * @param token the token that has been accepted.
	 */
	public void insertTerminal(Token token)
	{
		String tt = Token.getName(token.symbol);

		if((token.symbol == Token.identifier) || (token.symbol == Token.numberConstant) || (token.symbol == Token.stringConstant))
			tt += " '" + token.text + "'";

		tt += " on line " + token.lineNumber;

		System.out.println(String.join("", Collections.nCopies(NumberOfIndents, "    ")) + "rggTOKEN " + tt);
	}

	/**
	 * Outputs the name of a non-terminal that has started.
	 * @param name the name of the non-terminal that has started.
	 */
	public void commenceNonterminal(String name)
	{
		System.out.println(String.join("", Collections.nCopies(NumberOfIndents, "    ")) + "rggBEGIN " + name);
		NumberOfIndents += 1;
	}

	/**
	 * Outputs the name of a non-terminal that has finished.
	 * @param name the name of the non-terminal that has finished.
	 */
	public void finishNonterminal(String name)
	{
		NumberOfIndents -= 1;
		System.out.println(String.join("", Collections.nCopies(NumberOfIndents, "    ")) + "rggEND " + name);
	}
}